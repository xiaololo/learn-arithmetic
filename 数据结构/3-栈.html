<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>数据结构与算法</title>
</head>

<body>
  数据结构：
  栈 队列 链表 (有序)；
  集合 字典（无序）；
  树 堆 图 ；

  算法：
  链表：遍历链表，删除链表节点。
  树、图：深度/广度优先遍历。
  数组：冒泡/选择/插入/归并/快速排序、顺序/二分搜索。

  ------------------------------------------------------

  ## 栈是什么
  一个后进先出的数据结构 （push 入栈 pop出栈）
  javascript 没有栈，Array实现栈的所有功能；
  栈的常用操作：push pop stack[stack.length-1](栈顶)

  ## 应用场景（后进先出的场景）
  十进制转二进制
  判断字符串的括号是否有效
  函数调用堆栈

  ## 算法题
  leetCode:20.有限的括号

  ## 前端与栈
  JS中的函数调用堆栈

  ## 算法题  -- 看完二叉树接口后重新写
   leetCode:144.二叉树的前序遍历  
   栈可以模拟递归改写递归


  ## 思考题 -- 做题

  <script>

    //后进先出特性------------------------
    // const stack =[]
    // // 入栈
    // stack.push(1)
    // stack.push(2)
    // debugger;
    // console.log(stack) //[1,2]
    // // 出栈
    // const item1 = stack.pop() //2
    // const item2 = stack.pop() //1

    // 场景一：十进制转二进制-----------------
    // 见十进制转二进制.png
    // 后出来的余数反而要排到前面

    // 场景二：判断字符串的括号是否有效 -------------
    // 括号是否可以有效闭合
    // (((((((()))))))) valid
    // () () () () valid
    // (((((((() invalid
    // ((()(()))) valid

    // 越靠后的左括号，对应的右括号越靠前。
    // 左括号入栈，右括号出栈，最后栈空了就是合法的

    // 场景三：函数调用堆栈 -------------
    // function greeting(){
    //   sayHi();
    // }
    // function sayHi(){
    //   return "Hi!"
    // }

    // greeting()

    //最后调用的函数是最先执行完的
    //Js解释器使用栈来控制函数的调用顺序

    // ----------------------------------------------
    // leetCode:20.有限的括号
    // 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

    // 有效字符串需满足：

    // 左括号必须用相同类型的右括号闭合。
    // 左括号必须以正确的顺序闭合。

    // 解题思路：
    // 对于没有闭合的左括号而言，越靠后的左括号，对应的右括号越靠前
    // 满足后进先出，考虑用栈

    // 新建栈
    // 遍历字符串，遇左入栈，遇到和栈顶括号类型匹配的右括号出栈，类型不匹配直接判定不合法
    
    // 最后栈空合法，否则不合法

    
    // ----------------------------------------------
    // callStack.js
    // const fn1=()=>{
    // fn2()
    // }
    // const fn2=()=>{
    // fn3()
    // }
    // const fn3=()=>{}

    // fn1()

    // 执行时，调用堆栈的执行顺序：
    // fn1 fn2 fn3 
    // 执行结束：fn3 fn2 fn1

    // ----------------------------------------------
    //  leetCode:144.二叉树的前序遍历
    // 给你二叉树的根节点 root ，返回它节点值的 前序 遍历。


     // ----------------------------------------------
    // 请1.用 ES6 的 class，封装一个 Stack 类，包括 push、pop、peek 方法。
    class Stack{
      constructor(arr=[]){
        this.arr=arr
      }
      push(item){
        this.arr.push(item)
      }
      pop(){
        return this.arr.pop()
      }
      peek(item){
        return this.arr[arr.length-1]
      }
    }
    // 2.请用栈这个数据结构，将100这个十进制数字转为二进制。
    // 十进制转化为二进制的方法如下：

    // 8/2=4……0

    // 4/2=2……0

    // 2/2=1……0

    // 1/2=0……1

    // 只要将余数逆向排需就是了。

    // function fn(num){
    //   let res = '';
    //   const stack=[]
    //   while(num){
    //     num=parseInt(num/2)
    //     stack.push(num%2)
    //   }
    //   while(stack.length){
    //     res+= stack[stack.length-1] 
    //   }
    //   return res;
    // }
    // fn(20)

  </script>
</body>
</html>